#!/usr/bin/env python3
"""
ML Product Classifier - –û—Å–Ω–æ–≤–Ω–æ–π —Ñ–∞–π–ª –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞
by Morzh - –ü—Ä–æ–µ–∫—Ç —Å–æ–∑–¥–∞–Ω –¥–ª—è —Ä–∞–∑–≤–∏—Ç–∏—è –≤–∞–ª–∏–¥–∞—Ç–æ—Ä–∞ —Ç–æ–≤–∞—Ä–æ–≤ —ç–ª–µ–∫—Ç—Ä–æ–Ω–∏–∫–∏
"""

import os
import sys
import json
import logging
import time
import subprocess
import threading
from pathlib import Path

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–æ–¥–∏—Ä–æ–≤–∫–∏ –¥–ª—è Windows
if sys.platform == "win32":
    os.environ['PYTHONIOENCODING'] = 'utf-8'
    sys.stdout.reconfigure(encoding='utf-8')
    sys.stderr.reconfigure(encoding='utf-8')

# –î–æ–±–∞–≤–ª—è–µ–º –ø—É—Ç—å –∫ –º–æ–¥—É–ª—è–º
sys.path.append(str(Path(__file__).parent / "src"))

from ml_model import ProductClassifier

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    encoding='utf-8'
)
logger = logging.getLogger(__name__)

def parse_validation_response(response: str, products: list, elapsed_time: float) -> list:
    """–ü–∞—Ä—Å–∏—Ç—å –æ—Ç–≤–µ—Ç –≤–∞–ª–∏–¥–∞—Ü–∏–∏"""
    try:
        start = response.find('{')
        end = response.rfind('}') + 1
        
        if start != -1 and end != 0:
            json_str = response[start:end]
            parsed = json.loads(json_str)
            
            results = []
            for i, product in enumerate(products):
                # –ò—â–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ –∏–Ω–¥–µ–∫—Å—É
                product_result = None
                for result in parsed.get('results', []):
                    if result.get('index') == i + 1:
                        product_result = result
                        break
                
                if product_result:
                    results.append({
                        "product_name": product.get("name", ""),
                        "is_valid": product_result.get("is_valid", False),
                        "reason": product_result.get("reason", ""),
                        "processing_time": elapsed_time / len(products)
                    })
                else:
                    results.append({
                        "product_name": product.get("name", ""),
                        "is_valid": False,
                        "reason": "–ù–µ –Ω–∞–π–¥–µ–Ω –≤ –æ—Ç–≤–µ—Ç–µ",
                        "processing_time": elapsed_time / len(products)
                    })
            
            return results
        else:
            # Fallback
            return [{"error": "–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å –æ—Ç–≤–µ—Ç"}] * len(products)
            
    except json.JSONDecodeError:
        return [{"error": "–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ JSON"}] * len(products)

def main():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è"""
    try:
        logger.info("üöÄ –ó–∞–ø—É—Å–∫ ML Product Classifier")
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ç–æ—Ä
        logger.info("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ç–æ—Ä...")
        classifier = ProductClassifier()
        
        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –º–æ–¥–µ–ª–∏
        model_info = classifier.get_model_info()
        logger.info(f"–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –º–æ–¥–µ–ª–∏: {json.dumps(model_info, indent=2, ensure_ascii=False)}")
        
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –º–æ–¥–µ–ª—å
        logger.info("–ó–∞–≥—Ä—É–∂–∞–µ–º –º–æ–¥–µ–ª—å —á–µ—Ä–µ–∑ Ollama...")
        start_time = time.time()
        
        if not classifier.load_model():
            logger.error("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –º–æ–¥–µ–ª—å")
            return
        
        load_time = time.time() - start_time
        logger.info(f"‚úÖ –ú–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞ –∑–∞ {load_time:.2f} —Å–µ–∫—É–Ω–¥")
        
        # –¢–µ—Å—Ç–∏—Ä—É–µ–º –º–æ–¥–µ–ª—å
        logger.info("–¢–µ—Å—Ç–∏—Ä—É–µ–º –º–æ–¥–µ–ª—å...")
        test_products = [
            # –°–º–µ—à–∞–Ω–Ω—ã–µ —Ç–æ–≤–∞—Ä—ã –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏ "playstation 5"
            # –í–∞–ª–∏–¥–Ω—ã–µ PlayStation —Ç–æ–≤–∞—Ä—ã
            {
                'name': 'PlayStation 5',
                'description': '–ò–≥—Ä–æ–≤–∞—è –ø—Ä–∏—Å—Ç–∞–≤–∫–∞ Sony PlayStation 5'
            },
            {
                'name': 'PlayStation 5 Slim',
                'description': '–ö–æ–º–ø–∞–∫—Ç–Ω–∞—è –∏–≥—Ä–æ–≤–∞—è –ø—Ä–∏—Å—Ç–∞–≤–∫–∞ Sony PS5'
            },
            {
                'name': 'PlayStation 5 Pro',
                'description': '–ú–æ—â–Ω–∞—è –∏–≥—Ä–æ–≤–∞—è –ø—Ä–∏—Å—Ç–∞–≤–∫–∞ Sony PS5 Pro'
            },
            
            # –ù–µ–≤–∞–ª–∏–¥–Ω—ã–µ –∞–∫—Å–µ—Å—Å—É–∞—Ä—ã –∫ PlayStation
            {
                'name': 'DualSense Controller',
                'description': '–ë–µ—Å–ø—Ä–æ–≤–æ–¥–Ω–æ–π –≥–µ–π–º–ø–∞–¥ –¥–ª—è PlayStation 5'
            },
            {
                'name': 'PlayStation VR2',
                'description': 'VR –≥–∞—Ä–Ω–∏—Ç—É—Ä–∞ –¥–ª—è PlayStation 5'
            },
            
            # –ù–µ–≤–∞–ª–∏–¥–Ω—ã–µ —Ç–æ–≤–∞—Ä—ã –¥—Ä—É–≥–∏—Ö –±—Ä–µ–Ω–¥–æ–≤
            {
                'name': 'Nintendo Switch OLED',
                'description': '–ü–æ—Ä—Ç–∞—Ç–∏–≤–Ω–∞—è –∏–≥—Ä–æ–≤–∞—è –ø—Ä–∏—Å—Ç–∞–≤–∫–∞ Nintendo Switch'
            },
            {
                'name': 'Xbox Series X',
                'description': '–ò–≥—Ä–æ–≤–∞—è –ø—Ä–∏—Å—Ç–∞–≤–∫–∞ Microsoft Xbox Series X'
            },
            {
                'name': 'iPhone 15 Pro Max',
                'description': '–°–º–∞—Ä—Ç—Ñ–æ–Ω Apple iPhone 15 Pro Max'
            },
            {
                'name': 'NVIDIA RTX 4070 Ti',
                'description': '–í–∏–¥–µ–æ–∫–∞—Ä—Ç–∞ NVIDIA GeForce RTX 4070 Ti'
            },
            {
                'name': 'Intel Core i9-14900K',
                'description': '–ü—Ä–æ—Ü–µ—Å—Å–æ—Ä Intel Core i9 –¥–ª—è –Ω–∞—Å—Ç–æ–ª—å–Ω—ã—Ö –ü–ö'
            }
        ]
        
        # –¢–µ—Å—Ç –≤–∞–ª–∏–¥–∞—Ü–∏–∏ —Å –∑–∞–ø—Ä–æ—Å–æ–º "playstation 5"
        query = "playstation 5"
        test_batch = test_products[:10]  # –°–º–µ—à–∞–Ω–Ω—ã–µ —Ç–æ–≤–∞—Ä—ã
        logger.info(f"\nüîç –í–ê–õ–ò–î–ê–¶–ò–Ø: –ó–∞–ø—Ä–æ—Å '{query}' vs {len(test_batch)} —Ç–æ–≤–∞—Ä–æ–≤")
        logger.info(f"   –û–∂–∏–¥–∞–µ–º: PlayStation —Ç–æ–≤–∞—Ä—ã = –≤–∞–ª–∏–¥–Ω—ã, –æ—Å—Ç–∞–ª—å–Ω—ã–µ = –Ω–µ–≤–∞–ª–∏–¥–Ω—ã")
        
        # –°–æ–∑–¥–∞–µ–º –ø—Ä–æ–º–ø—Ç –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏
        validation_prompt = f"""
–ó–∞–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: "{query}"

–ü—Ä–æ–≤–µ—Ä—å –∫–∞–∂–¥—ã–π —Ç–æ–≤–∞—Ä - –ø–æ–¥—Ö–æ–¥–∏—Ç –ª–∏ –æ–Ω –ø–æ–¥ —ç—Ç–æ—Ç –∑–∞–ø—Ä–æ—Å?

–¢–æ–≤–∞—Ä—ã:
"""
        
        for i, product in enumerate(test_batch, 1):
            validation_prompt += f"""
{i}. {product['name']}
   –û–ø–∏—Å–∞–Ω–∏–µ: {product['description']}
"""
        
        validation_prompt += f"""

–û—Ç–≤–µ—Ç –≤ —Ñ–æ—Ä–º–∞—Ç–µ JSON:
{{
  "query": "{query}",
  "results": [
    {{
      "index": 1,
      "product_name": "–Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞",
      "is_valid": true/false,
      "reason": "–æ–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ"
    }}
  ]
}}

–í–∞–ª–∏–¥–Ω—ã–º–∏ —Å—á–∏—Ç–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –æ—Å–Ω–æ–≤–Ω—ã–µ —Ç–æ–≤–∞—Ä—ã PlayStation 5, –∞–∫—Å–µ—Å—Å—É–∞—Ä—ã - –Ω–µ–≤–∞–ª–∏–¥–Ω—ã.
"""
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –º–æ–¥–µ–ª–∏
        logger.info(f"‚è≥ –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –º–æ–¥–µ–ª–∏...")
        
        # ASCII-–∞—Ä—Ç –∞–Ω–∏–º–∞—Ü–∏—è
        loading_frames = ["8uu==3", "8==uu3"]
        current_frame = 0
        animation_running = True
        
        def animate():
            nonlocal current_frame
            while animation_running:
                frame = loading_frames[current_frame % len(loading_frames)]
                sys.stdout.write(f"\r‚è≥ {frame} –í–∞–ª–∏–¥–∞—Ü–∏—è –∑–∞–ø—Ä–æ—Å–∞ '{query}'...")
                sys.stdout.flush()
                current_frame += 1
                time.sleep(0.3)
        
        animation_thread = threading.Thread(target=animate, daemon=True)
        animation_thread.start()
        
        start_time = time.time()
        
        result = subprocess.run(
            ["ollama", "run", "t-pro-it-2.0-optimized", validation_prompt],
            capture_output=True,
            text=True,
            encoding='utf-8',
            timeout=300
        )
        
        animation_running = False
        sys.stdout.write("\r" + " " * 80 + "\r")
        sys.stdout.flush()
        
        elapsed_time = time.time() - start_time
        
        if result.returncode != 0:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏: {result.stderr}")
            batch_results = [{"error": "–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏"}] * len(test_batch)
        else:
            response = result.stdout.strip()
            logger.info(f"‚úÖ –í–∞–ª–∏–¥–∞—Ü–∏—è –≥–æ—Ç–æ–≤–∞! –í—Ä–µ–º—è: {elapsed_time:.2f} —Å–µ–∫")
            batch_results = parse_validation_response(response, test_batch, elapsed_time)
        
        batch_time = 0
        for i, result in enumerate(batch_results, 1):
            if 'error' in result:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ç–æ–≤–∞—Ä {i}: {result['error']}")
            else:
                product_name = result.get('product_name', f'–¢–æ–≤–∞—Ä {i}')
                is_valid = result.get('is_valid', False)
                reason = result.get('reason', '')
                status = "‚úÖ –í–ê–õ–ò–î–ï–ù" if is_valid else "‚ùå –ù–ï–í–ê–õ–ò–î–ï–ù"
                logger.info(f"{status} {i}: {product_name}")
                if reason:
                    logger.info(f"   –ü—Ä–∏—á–∏–Ω–∞: {reason}")
                batch_time += result.get('processing_time', 0)
        
        avg_batch_time = batch_time / len(test_batch) if test_batch else 0
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏
        valid_count = 0
        invalid_count = 0
        for result in batch_results:
            if 'error' not in result:
                if result.get('is_valid', False):
                    valid_count += 1
                else:
                    invalid_count += 1
        
        logger.info(f"\nüìà –†–ï–ó–£–õ–¨–¢–ê–¢–´ –í–ê–õ–ò–î–ê–¶–ò–ò:")
        logger.info(f"   –û–±—â–µ–µ –≤—Ä–µ–º—è: {batch_time:.2f} —Å–µ–∫")
        logger.info(f"   –°—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è –Ω–∞ –ø—Ä–æ–¥—É–∫—Ç: {avg_batch_time:.2f} —Å–µ–∫")
        logger.info(f"   –í—Å–µ–≥–æ —Ç–æ–≤–∞—Ä–æ–≤: {len(test_batch)}")
        logger.info(f"   ‚úÖ –í–∞–ª–∏–¥–Ω—ã—Ö: {valid_count}")
        logger.info(f"   ‚ùå –ù–µ–≤–∞–ª–∏–¥–Ω—ã—Ö: {invalid_count}")
        
        # –î–µ—Ç–∞–ª—å–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è
        logger.info(f"\nüîç –î–ï–¢–ê–õ–¨–ù–ê–Ø –í–ê–õ–ò–î–ê–¶–ò–Ø:")
        logger.info(f"   –û–∂–∏–¥–∞–µ–º—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ vs –§–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ:")
        
        expected_validation = {
            'PlayStation 5': True,
            'PlayStation 5 Slim': True, 
            'PlayStation 5 Pro': True,
            'DualSense Controller': False,
            'PlayStation VR2': False,
            'Nintendo Switch OLED': False,
            'Xbox Series X': False,
            'iPhone 15 Pro Max': False,
            'NVIDIA RTX 4070 Ti': False,
            'Intel Core i9-14900K': False
        }
        
        correct = 0
        total = 0
        
        for i, result in enumerate(batch_results):
            if 'error' not in result:
                product_name = result.get('product_name', '')
                is_valid = result.get('is_valid', False)
                expected = expected_validation.get(product_name, False)
                
                is_correct = is_valid == expected
                if is_correct:
                    correct += 1
                total += 1
                
                status = "‚úÖ" if is_correct else "‚ùå"
                expected_text = "–≤–∞–ª–∏–¥–µ–Ω" if expected else "–Ω–µ–≤–∞–ª–∏–¥–µ–Ω"
                actual_text = "–≤–∞–ª–∏–¥–µ–Ω" if is_valid else "–Ω–µ–≤–∞–ª–∏–¥–µ–Ω"
                logger.info(f"   {status} {product_name}")
                logger.info(f"      –û–∂–∏–¥–∞–ª–æ—Å—å: {expected_text} | –ü–æ–ª—É—á–µ–Ω–æ: {actual_text}")
        
        accuracy = (correct / total * 100) if total > 0 else 0
        logger.info(f"\nüìà –¢–û–ß–ù–û–°–¢–¨ –í–ê–õ–ò–î–ê–¶–ò–ò: {accuracy:.1f}% ({correct}/{total})")
        
        # –¢–µ—Å—Ç –ø–æ –æ–¥–Ω–æ–º—É –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
        logger.info(f"\nüîç –¢–µ—Å—Ç –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏–∏ –ø–æ –æ–¥–Ω–æ–º—É")
        single_total_time = 0
        test_count = 0
        for i, product in enumerate(test_products[:5], 1):  # –ü–µ—Ä–≤—ã–µ 5 —Ç–æ–≤–∞—Ä–æ–≤
            logger.info(f"üß™ –¢–µ—Å—Ç {i}: {product['name']}")
            result = classifier.classify_product(product)
            
            if 'error' in result:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞: {result['error']}")
            else:
                logger.info(f"‚úÖ –†–µ–∑—É–ª—å—Ç–∞—Ç: {result['predicted_category']} ({result['confidence']:.2f})")
                single_total_time += result.get('processing_time', 0)
                test_count += 1
        
        avg_single_time = single_total_time / test_count if test_count > 0 else 0
        logger.info(f"\nüìä –°—Ä–∞–≤–Ω–µ–Ω–∏–µ:")
        logger.info(f"   –ë–∞—Ç—á: {avg_batch_time:.2f} —Å–µ–∫/—Ç–æ–≤–∞—Ä")
        logger.info(f"   –ü–æ –æ–¥–Ω–æ–º—É: {avg_single_time:.2f} —Å–µ–∫/—Ç–æ–≤–∞—Ä")
        
        if avg_batch_time > 0 and avg_single_time > 0:
            if avg_batch_time < avg_single_time:
                speedup = avg_single_time / avg_batch_time
                logger.info(f"üöÄ –ë–∞—Ç—á –±—ã—Å—Ç—Ä–µ–µ –≤ {speedup:.1f}x —Ä–∞–∑!")
            else:
                speedup = avg_batch_time / avg_single_time
                logger.info(f"‚ö° –û–¥–∏–Ω–æ—á–Ω–∞—è –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è –±—ã—Å—Ç—Ä–µ–µ –≤ {speedup:.1f}x —Ä–∞–∑!")
        else:
            logger.info("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —Å—Ä–∞–≤–Ω–∏—Ç—å –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å")
        
        logger.info("‚úÖ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ")
        
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤ main: {str(e)}")
        raise

if __name__ == "__main__":
    main() 